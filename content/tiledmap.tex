Als Karte benutzt absGDX ein Tiled-Map System. Die Karte ist unterteilt in viele einzelne quadratische Tiles.
Jedes Tile hat eine eigene Textur und zusammen bilden sie die Karte. Die Texturen kommen meist aus einer sogenannten Tilemap, in der eine gro√üe Anzahl an Texturen in einer einzigen Datei zusammengefasst sind.

\quickfigure{Visualisierung einer Tiled Map}{tilemap_all}{1.0}

In absGDX wird eine solche Map durch eine Instanz der Klasse \keyword{TileMap} repr√§sentiert. Diese Klasse verwaltet intern seine einzelnen Tiles in einem zweidimensionalen Array und bietet Methoden um Tiles abzufragen oder zu √§ndern.

Die einzelnen Tiles m√ºssen von der abstrakten Klasse \keyword{Tile} abgeleitet werden. Man kann seine Tiles entweder direkt von dieser Klasse ableiten oder eine Unterklasse benutzen die jeweils f√ºr speziellere F√§lle zugeschnitten sind:

\begin{itemize}
  \item \keyword{AnimationTile} Wenn von AnimationTile abgeleitet wird, kann man der Tile nicht nur eine statische Textur zuweisen, sondern eine sich wiederholende Animation
  \item \keyword{EmptyTile} EmptyTiles sind Tiles ohne Textur oder Logik - sie werden standardm√§√üig f√ºr neue Maps eingesetzt
  \item \keyword{StaticTile} StaticTiles haben eine statische Textur und	keine Logik, rein-grafische Tiles k√∂nne hiervon abgeleitet werden
  \item \keyword{AutoTile} AutoTiles sind n√ºtzlich in Zusammenhang mit aus Dateien geladenen Maps. Sie beziehen ihre Textur automatisch aus der gegebenen Tilemap
\end{itemize}

\paragraph{Ermitteln der absoluten Gr√∂√üe}

Intern besitzen alle Tiles die Dimension 1.0 x 1.0. Beim eigentlichen Anzeigen m√ºssen diese Werte jedoch auf eine konkrete Pixelzahl skaliert werden. Dies kann komplex werden, da besonders mobile Ger√§te in einer Vielzahl an Aufl√∂sungen und Verh√§ltnissen kommen. Au√üerdem kann es anwendungsspezifische Vorgaben geben, wie beispielsweise eine minimale Anzahl an Tiles, die auf jeden Fall sichtbar sein sollten.
Um dies zu l√∂sen gibt, es verschiedene Ans√§tze, jeweils repr√§sentiert durch eine Klasse, abgeleitet von \keyword{AbstractMapScaleResolver}.
Ein MapScaleResolver berechnet aus den Kartendimensionen und den Dimensionen des Anzeigeger√§tes die echte H√∂he und Breite eines Tiles in pixel.
Standardm√§√üig sind in absGDX sechs verschiedene MapScaleResolver enthalten:

\subparagraph{FixedMapScaleResolver} 
Dies ist der einfachste MapScaleResolver. Er gibt immer eine konstante, vorher bestimmte Gr√∂√üe zur√ºck. (z.B. 60px)

\quickfigure{Visualisierung des FixedMapScaleResolver}{tilemap_fixed}{1.0}
  
\subparagraph{ShowCompleteMapScaleResolver} 
Hier wird immer die komplette Karte angezeigt. Falls das Verh√§ltnis von Kartenbreite und H√∂he nicht mit dem des Anzeigeger√§tes √ºbereinstimmt, gibt es Teile des Bildschirms, die nicht von der Karte bedeckt sind.

\quickfigure{Visualisierung des ShowCompleteMapScaleResolver}{tilemap_complete}{1.0}
  
\subparagraph{MaximumBoundaryMapScaleResolver} 
Bei dieser L√∂sung wird eine Grenzfl√§che festgelegt, die \textbf{immer} angezeigt wird, beispielsweise drei mal drei Tiles. 
Es kann vorkommen, dass mehr Tiles angezeigt werden (z.B.: 3x3.5 Tiles), es ist jedoch garantiert, dass die Grenzfl√§che selbst immer zu sehen ist.

\quickfigure{Visualisierung des MaximumBoundaryMapScaleResolver}{tilemap_maximum}{1.0}
  
\subparagraph{MinimumBoundaryMapScaleResolver} 
Dies ist das Gegenst√ºck zum \keyword{MaximumBoundaryMapScaleResolver}. 
Hier wird eine Grenzfl√§che festgelegt, die nie √ºberschritten wird. 
Ist diese zum Beispiel 10x5 Tiles kann es sein, dass nur 10x3 angezeigt werden. Es wird aber nie mehr als die Grenzfl√§che gezeigt und immer versucht sich dieser soweit wie m√∂glich anzun√§hern, ohne die Karte zu verzerren.

\quickfigure{Visualisierung des MinimumBoundaryMapScaleResolver}{tilemap_minimum}{1.0}
  
\subparagraph{LimitedMinimumBoundaryMapScaleResolver} 
Dieser MapScaleResolver baut auf dem \keyword{MinimumBoundaryMapScaleResolver} auf. 
Er nimmt zuerst die gleichen Regeln wie dieser, beinhaltet aber einen Ausnahmefall. 
Es ist wird niemals mehr als x Prozent der urspr√ºnglichen Grenzfl√§che weggeschnitten. 
Diese Regel hat eine h√∂here Priorit√§t als die minimale Grenzfl√§che und somit kann es dazu kommen, dass eben doch mehr als die Grenzfl√§che gezeigt wird.

\quickfigure{Visualisierung des LimitedMinimumBoundaryMapScaleResolver}{tilemap_limited}{1.0}
  
\subparagraph{SectionMapScaleResolver} 
Dies ist eine nochmalige Erweiterung des \keyword{LimitedMinimumBoundaryMapScaleResolver}. 
Neben der maximalen Schnittfl√§che gibt es hier jetzt auch noch eine minimale Gr√∂√üe eines Tiles. 
Ein Tile kann niemals kleiner als eine angegebene Anzahl Pixel werden. Diese Regel hat die h√∂chste Priorit√§t und kann gegebenenfalls die anderen beiden au√üer Kraft setzen.

\quickfigure{Visualisierung des SectionMapScaleResolver}{tilemap_section}{1.0}

\paragraph{Das Rendern}

Das Rendern der Karte wird von dem aktuellen Layer √ºbernommen. Dies ist in den meisten F√§llen ein GameLayer, da nur dieser eine TiledMap besitzt.
H‰ufig ist nicht die ganze Map sichtbar, da der aktuelle MapScaleResolver die Tiles gro√ü genug macht, um mehr als das gesamte Display auszuf√ºllen. Deshalb gibt es im \keyword{GameLayer} einen \ti{MapOffset}. Dieser gibt an wie weit die Karte in X und Y Richtung verschoben ist.
Beim Rendern ist nun darauf zu achten, dass man nur die Tiles rendert die ganz oder teilweise sichtbar sind. Man k√∂nnte zwar auch einfach alle anzeigen, dies w√§re jedoch nicht sehr performant. Es ist jedoch einfach zu berechnen welche Tiles aktuell sichtbar sind:\cite[S 232f.]{DGIJ}

\doinline
\begin{lstlisting}[caption=Ermitteln der aktuell sichtbare Tiles, title=\hspace{0 pt}, language=java]
public Rectangle getVisibleMapBox() {
	float tilesize = mapScaleResolver.getTileSize(owner.getScreenWidth(), owner.getScreenHeight(), map.height, map.width);
	
	Rectangle view = new Rectangle(map_offset.x, map_offset.y, owner.getScreenWidth() / tilesize, owner.getScreenHeight() / tilesize);
	
	return view;
}
\end{lstlisting}

\paragraph{Laden aus dem TMX Format}

TileMaps kann man mit dem Programm Tiled erstellen \footnote{\url{http://www.mapeditor.org/}} welche TMX Dateien generiert. Da dies ein bekanntes Format ist, haben wir auch in absGDX die Funktion implementiert solche Dateien zu laden. Eine TMX Datei ist eine einfache xml Datei mit einem vorgegebenen Format \footnote{\url{http://mapeditor.org/dtd/1.0/map.dtd}}:

\doinline
\begin{lstlisting}[caption=Beipiel einer TMX Datei, title=\hspace{0 pt}, language=xml]
<?xml version="1.0" encoding="UTF-8"?>
<map version="1.0" orientation="orthogonal" width="128" height="128" tilewidth="16" tileheight="16">
 <layer name="Kachelebene 1" width="128" height="128">
  <data encoding="base64" compression="gzip">
   H4sIAAAAAAAAC72d2Z5r13HeD/DtFs1zlMFJbjLcA==
  </data>
 </layer>
</map>
\end{lstlisting}

TMX unterst√ºtzt verschiedene Karten und Tilegr√∂√üen, mehrere Layer und auch fest eingebundene Tilesets. Die eigentlichen Daten sind entweder in XML, CSV oder als base64-bin√§r Daten kodiert. Zus√§tzlich kann entweder keine, \ti{gzip} oder \ti{zlib} Kompression vorliegen\footnote{\url{https://github.com/bjorn/tiled/wiki/TMX-Map-Format\#data}}.

Als XML Parser haben wir uns f√ºr die XMLReader Library entschieden, welche schon in LibGDX integriert ist und auf allen Zielplattformen funktioniert. XMLReader ist ein java-XML-DOM Parser. Dies bedeutet, dass die komplette Datei analysiert und in den Speicher geladen wird. Dies macht das Auswerten der Datei sehr einfach, verbraucht aber mehr Arbeitsspeicher als beispielsweise ein SAX-Parser. Da die TMX Dateien jedoch nicht sehr gro√ü sind im Verh√§ltnis zum gew√∂hnlich verf√ºgbaren Arbeitsspeicher sollte dies keine Probleme bereiten.

Das Parsen einer TMX Datei wird von der Klasse \keyword{TmxParser} √ºbernommen. Nach dem Laden der XML Datei geht dieser zuerst die einzelnen Layer von dem niedrigsten angefangen durch. F√ºr jeden Layer m√ºssen die Daten dekodiert werden. Sind sie in gzip oder zlib komprimiert, muss man sie zuerst dekomprimieren. Sind die Daten dann in XML kodiert, kann der XOM Parser einfach ebenfalls die Daten parsen. Auch CSV kodierte Daten k√∂nnen recht einfach mit der in java enthaltenen \keyword{String.split} Funktion analysiert werden.
Bei Base64 Daten ist der Prozess jedoch komplizierter. Zuerst muss der String als Reihe von Bytes interpretiert werden. Danach gruppiert man jeweils 3 bytes zusammen und interpretiert sie als Little-Endian unsigned 32bit-Integer. Der entstehende Int32-Array sind dann die GIDs der Tiles.

In allen 3 F√§llen erh√§lt man einen Integer Array. Die einzelnen Integer sind die sogenannten GIDs, welche den Tiletyp eindeutig identifiziern (anhand der Texturposition im Tileset).
Die GIDs fangen bei 1 an, eine 0 bedeutet "kein Tile". Unser \keyword{TmxParser} erstellt dann f√ºr jede GID die entsprechende Tile und bildet aus ihnen eine TileMap.

Die Zuordnung von GID und Tile-Klasse muss der Entwickler bestimmen. Er kann daf√ºr mit der Methode \keyword{addMapping(int, class)} eine GID einer bestimmten Tile-Klasse zuordnen. Beim Erstellen der Map wird dann jeweils nach einer solchen Zuordnung gesucht. Falls es eine gibt, wird mittels java Reflection der Konstruktor der Klasse ermittelt und eine neue Instanz erzeugt. Daf√ºr ist es notwendig dass alle Klassen, die von Tile ableiten entweder einen Konstruktor ohne Parameter haben oder einen, der eine Settingsmap nimmt. Eine Settingsmap ist eine \keyword{Hashmap<String, String>} in welcher verschiedene Informationen √ºber das Tile enthalten sind wie Position, GID, Mapgr√∂√üe etc. Falls vorhanden, wird immer der Konstruktor mit der Hashmap genommen. Nur falls dieser nicht existiert wird der leere benutzt.

Eine geschickte Verwendung dieser Mechanik ist beispielsweise die \keyword{AutoTile} Klasse. Setzt man im Mapping diese Klasse als Default Mapping ein und sonst keine andere Klasse, werden alle GIDs auf AutoTile gemappt. Die AutoTile Klasse hat dann einen Konstruktor mit einer Settingsmap und berechnet aus der darin enthaltenen GID zur√ºck, welche Textur im TILED MapEditor verwendet wurde. Man verliert zwar somit die M√∂glichkeit, unterschiedlichen Tiles speziellen Code zuzuordnen, braucht jedoch bei einem gro√üen Tileset nicht sehr viele Klassen, die sich kaum unterscheiden.

Man muss dem Programm nur die Tilmap und das Tileset zur Verf√ºgung stellen und kann die Karte direkt mit Grafiken in das Programm laden.