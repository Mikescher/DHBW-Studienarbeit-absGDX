% Einleitung CD (warum etc)
% Bedingungen an Algo

% Aufteilung Entities <-> CollisionGeos
% Relative CollisionGeos
% -> muss auf geo-pos change reagieren (deshalb gibt entity den Position-vector nicht public) -> ref zu punkt unter Collmap wo das nochmal kommt
% CollisionCircle <-> Box

% Optimierungen (len2 / zuerst circle testen)

% Erklärung CollisionMap
% -> Map
% -> muss auf geo-pos change reagieren (deshalb gibt entity den Position-vector nicht public)
% Optimierung durch versch expTileScales
% Optimierung NO-OP Movement
% Optimierung Pseudo Geos
% Implementierung Active / Passive collision
% PROBLEM :-> Out of map Handling


% Performancevergleich (box testing / circle first testing)

% Collision aware movement
% - X/Y independent moving (-> semi-sliding)
% Implementierung Active / Passive movement collision
% - PROBLEM :-> Collision mit mehreren Geos (collide mit erster)
% - PROBLEM :-> FP Rundung (Collision aware movement) -> Nach movement intersecten die geos immernoch --> delta
% - PROBLEM :-> Discrete Time Issue (Book reference)

% Tile Collisions

% don't collide with everything
% -> commutative method
% -> getClass() vs instanceof

Eine wichtige Funktionalität, die unser Framework übernehmen soll ist es Kollisionen zwischen Entities zu erkennen. Beispielsweise muss ein Spiel erkennen ob das Spieler-Entity gerade mit einem Gegner kollidiert oder ob beispielsweise die Kugel-Entities etwas treffen. Eine solche Kollisionserkennung kann man unterschiedlich komplex implementieren, da unser Framework als primäre Zielplattform jedoch mobile Geräte hat ist hierbei die Performance besonders wichtig.

Das Ziel ist es nun ein Algorithmus zu entwickeln, welcher folgende Eigenschaften erfüllt:

\begin{itemize}
\item Der Algorithmus sollte auch bei vielen Entities auf der Karte noch schnell sein und die \ti{Update-Time} nicht unnötig erhöhen
\item Der Algorithmus sollte genau sein und weder \ti{False-Positives} noch \ti{False-Negatives} haben. Zwar kann es Anwendungen geben, wo eine genaue Erkennung nicht immer nötig ist, doch da unser Framework für eine Vielzahl an Anwendungen funktionieren soll muss der Algorithmus exakt sein.
\item Es sollte möglich sein Entities ohne Kollisionserkennung hinzuzufügen ohne dass diese Einfluss auf die \ti{Update-Time} haben.
\end{itemize}

\paragraph{Die CollisionGeometry Klasse}

Wir haben uns in unserem Ansatz dagegen entschieden die Kollision zwischen Entities direkt zu berechnen. Dies würde zwar die Handhabung des Frameworks vereinfachen würde aber auch zu einigen Problemen führen: Einerseits könnte es keine rein-visuellen Entities geben welche mit nichts kollidieren und keinen Einfluss auf die Performance haben. Außerdem kann es auf der anderen Seite auch keine Entities mit mehreren Bereichen geben welche jeweils einzeln kollidieren können. 
Stattdessen gibt es neben den Entities auf der Karte auch noch sogenannten \keyword{CollisionGeometries} welches die Elemente sind die miteinander kollidieren.
Ein Entity kann nun ein- / kein-, oder mehrere \keyword{CollisionGeometries} haben und auf deren Kollisionen reagieren. Beispielsweise kann der Kopf einer Figur eine andere Hitbox als der Körper haben und anders auf eintreffende Kugeln reagieren.

Jede Entity hat nun eine Liste mit von \keyword{EntityCollisionGeometry}. Dies ist ein einfacher Wrapper über die Klasse \keyword{CollisionGeometry}, die die Geometrie zusammen mit der relativen Position zum Entity enthält.

\begin{lstlisting}[caption=Die Klasse EntityCollisionGeometry, title=\hspace{0 pt}, language=java]
public class EntityCollisionGeometry {
	public final Vector2 relativePosition;
	public final CollisionGeometry geometry;

	public EntityCollisionGeometry(Vector2 relativePos, CollisionGeometry geo) {
		super();
		
		this.relativePosition = relativePos;
		this.geometry = geo;
	}
	
	public void updatePosition(float x, float y) {
		geometry.setCenter(x + relativePosition.x, y + relativePosition.y);
	}
}
\end{lstlisting}

Jedes mal wenn die Entity eine Veränderung ihrer Position erfährt wird updatePosition() aufgerufen und auch die \keyword{CollisionGeometry} bewegt sich mit.
Mit dieser Technik kann man auch komplexere Geometrie Gebilde bauen welche die Form des Entities beliebig genau annähern kann. \cite[S 500]{DGIJ} %TODO Alle DGIJ cites in dieser Datei überprüfen - die Seitenzahlen sind aus der PDF

\quickfigure{Beispiel eines Entities mit mehreren Hitboxen}{angel}{0.4} %TODO Engel mit boxen

Aktuell gibt es zwei verschiedene Arten von \keyword{CollisionGeometry}: \keyword{CollisionCircle} und \keyword{CollisionBox}. Das eine hat die Form eines Kreises und die andere die eines Rechteckes. In den meisten Fällen möchte man Hitboxen in der Form von Rechtecken, es kann jedoch überlegenswert sein nur Kreise zu verwenden da bei diesen die Kollisionsberechnung schneller ist.

Für den Fall Kollision Kreis-Kreis ist die Formel um zu berechnen ob sie sich schneiden sehr einfach:
$ Abstand < (Radius_1 + Radius_2) $ was in unserem Fall zu $ sqrt((x_1 - x_2)^2 + (y_1 - y_2)^2) < (r_1 + r_2)$ wird. Dies kann noch weiter optimiert werden indem man beide Seiten quadriert: $ x_1 - x_2)^2 + (y_1 - y_2)^2 < (r_1 + r_2)^2 $ \cite[S 499]{DGIJ}. Dies liegt daran, dass eine Multiplikation um mehrere Größenordnungen schneller als eine Quadratwurzel ist, ersteres ist meist ein einzelner Maschinenbefehl.

Den Vorteil einer Kreis-Kreis Kollision kann man auch auf alle anderen Geometrien anwenden indem man alle Geometrien als umschließende Kreise abschätzt und diese zuerst kollidieren lässt. Nur wenn die umschließenden Kreise sich überschneiden muss man dann den komplizierteren Schritt machen und die genauen Geometrien kollidieren lassen.

Dies führt dazu dass es 3 Fälle von Kollisionsberechnung gibt:

\doinline
\begin{lstlisting}[caption=Erkennen von Kollisionen, title=\hspace{0 pt}, language=java]
public static boolean doGeometriesIntersect(CollCircle a, CollCircle b) {
	return fsquare(a.centerX-b.centerX) + fsquare(a.centerY-b.centerY) < fsquare(a.radius + b.radius);
}

public static boolean doGeometriesIntersect(CollCircle a, CollBox b) {
	if (a.centerY > b.y && a.centerY < b.topY)
		return a.centerX > (b.x - a.radius) && 
			a.centerX < (b.rightX + a.radius);
	else if (a.centerX > b.x && a.centerX < b.rightX)
		return a.centerY > (b.y - a.radius) && 
			a.centerY < (b.topY + a.radius);
	else return 
		fsquare(a.centerX-b.x) + fsquare(a.centerY-b.y) < fsquare(a.radius) ||
		fsquare(a.centerX-b.rightX) + fsquare(a.centerY-b.y) < fsquare(a.radius) ||
		fsquare(a.centerX-b.rightX) + fsquare(a.centerY-b.topY) < fsquare(a.radius) ||
		fsquare(a.centerX-b.x) + fsquare(a.centerY-b.topY) < fsquare(a.radius);
}

public static boolean doGeometriesIntersect(CollBox a, CollBox b) {
	return ! (a.rightX < b.x || b.rightX < a.x || 
		a.topY < b.y || b.topY < a.y);
}
\end{lstlisting}

Die Kollisionserkennung zwischen zwei Kreisen oder zwei Rechtecken ist recht simpel. Nur eine Kreis-Rechteck Kollision ist etwas komplexer zu bestimmen.
Zuerst muss man bestimmen ob der Kreis neben, über oder unter dem Rechteck liegt, falls ja bestimmt man den Abstand der jeweiligen Seite und des Kreismittelpunktes. Wenn dieser Abstand kleiner als der Kreisradius ist schneiden sich die beiden Geometrien.

\quickfigure{Kollisionserkennung Kreis-Rechteck (1)}{circle-rect-coll-1}{0.4}

Wenn der Kreis andererseits schräg im Verhältnis zum Rechteck liegt muss man schauen ob das jeweilige Eck im Kreis liegt, hierfür bestimmt man den Abstand Eck - Kreismuittelpunkt und überprüft ob dieser kleiner dem Kreisradius ist.

\quickfigure{Kollisionserkennung Kreis-Rechteck (2)}{circle-rect-coll-2}{0.4}

\paragraph{Optimierung mit der Collisionmap}

Das grundlegende Problem dass dieser Algorithmus bis jetzt noch hat ist dass mit steigender Geometrie Anzahl die Anzahl der Vergleiche quadratisch ansteigt. 
Es müssen aktuell nämlich jede \keyword{CollisionGeometry} mit jeder anderen getestet werden und überprüft werden ob sie sich überschneiden.
Die meisten dieser Operationen sind offensichtlich unnötig - wenn sich zwei Geometrien auf unterschiedlichen Seiten der Karte befinden können sie in keinem Fall miteinander kollidieren (den Fall von Entities die fast so groß wie die Karte sind ausgeschlossen).

Unsere Lösung liegt darin die Datenstruktur zu ändern. Bisher wurden die CollisionGeometrien in einer einzigen großen Liste gespeichert, jetzt speichern wir sie in einem zweidimensionalen Raster.
Man muss sich das so vorstellen dass man die Karte in ein Raster unterteilt. Jedes dieser Raster-Felder wird von einem Objekt der Klasse \keyword{CollisionMapTile} dargestellt und jedes Objekt enthält eine Liste der CollisionGeometrien die auf diesem Tile sind.
Das bedeutet das jedes mal wenn eine CollisionGeometry hinzugefügt wird oder sich bewegt werden die Tiles berechnet auf denen die Geometrie sich befindet. Die CollisionGeometry wird dann in die Listen aller dieser Tiles hinzugefügt. Möchte man nun wissen ob eine Geometrie mit einer anderen kollidiert geht man alle Tiles durch auf denen diese Geometrie liegt. Den eigentlichen Überschneidung-Test-Code führt man dann auf allen Geometrien aus die man in diesem Tiles findet. Die vorherigen Optimierungen, wie dass man zuerst eine Kreiskollision durchführt, bleiben immer noch in Stand. Mit dieser Methode haben wir die Anzahl der zu überprüfenden Geometrien von allen enthaltenen auf ein paar in der Nähe eingeschränkt.

Diese \keyword{CollisionMap} muss nun immer aktuell gehalten werden, jedes mal wenn eine Geometrie hinzugefügt/bewegt/entfernt wird muss die jeweilige Methode aufgerufen werden um die \keyword{CollisionMap} zu aktualisieren. Dies ist auch der technische Grund warum sowohl bei \keyword{Entity} als auch bei \keyword{CollisionGeometry} der \ti{position}-Vektor nicht öffentlich ist sondern nur durch Setter verändert werden kann. Denn dadurch kann man diese Events abfangen und an die \keyword{CollisionMap} weitergeben.

Eine Frage ist nun wie die \keyword{CollisionMapTiles} skaliert werden sollen. Der Standard Ansatz unseres Frameworks ist es da die \keyword{CollisionMapTiles} gleich groß wie die normalen Map \keyword{Tiles} zu haben.
Dies ist als Standard Ansatz in soweit gut, dass normalerweise eine Map weder nur ein paar Tiles noch eine extreme Anzahl Tiles hat und meist sind maximal eine Hand voll Entities gleichzeitig auf einer Tile.
Trotzdem bieten wir dem Benutzer die Möglichkeit die Tilegröße manuell anzupassen.
Dafür gibt es im \keyword{CollisionMap}-Konstruktor den Parameter \ti{expTileScale}.
Dieser ist das Verhältnis von MapTiles zu CollisionTiles in der Form $ 2^n $.
Der Wert 0 ist hierbei Standard und beschreibt den Fall MapTiles == CollisionTiles.
Ein Wert von 1 würde CollisionTiles bewirken die doppelt so groß sind wie die MapTiles ($2^1 = 2$) und ein Wert von -1 halb so große ($2^{-1} = \frac{1}{2}$)

Um dies nun implementieren zu können muss man für eine Geometrie berechnen können auf welchen Tiles sie sich befindet.
Zuerst muss man die Position auf den Map Tiles in eine Position auf den CollisionTiles umwandeln:

\doinline
\begin{lstlisting}[caption=Berechnen der CollisionMap-Position aus der Tile-Position, title=\hspace{0 pt}, language=java]
private int getTileX(float x) {
	if (expTileScale < 0) {
		return (int) (x * 1d * (1 << -expTileScale));		
	} else if (expTileScale == 0) {
		return (int) x;
	} else {
		return (int) (x * 1d  / (1 << expTileScale));
	}
}

private int getTileY(float y) {
	if (expTileScale < 0) {
		return (int) (y * 1d * (1 << -expTileScale));		
	} else if (expTileScale == 0) {
		return (int) y;
	} else {
		return (int) (y * 1d  / (1 << expTileScale));
	}
}
\end{lstlisting}

Jedoch muss man hier auch den Ausnahmefall beachten. Eine Geometrie muss nicht zwangsweise auf der Karte sein, theoretisch kann sie sich auch daneben befinden.
Für diesen Fall haben wir einen zweiten 3x3 \keyword{CollisionMapTile}-Array welcher die 8 Bereiche um die Karte herum bezeichnet (Oben, Oben-Rechts, Rechts, Unten-Rechts, Unten, Unten-Link, Links, Oben-Links). Zwar hat man für den Fall von Kollisionen außerhalb der Karte keinen Vorteil durch die \keyword{CollisionMap}, sondern effektiv wieder den gleichen Fall wie vor deren Einführung. Aber dafür ist nun auch dort Kollisionserkennung möglich.

Neben der TilePosition muss nun auch der Radius berechnet werden, alle CollisionTiles innerhalb dieses Radius werden dann mit der entsprechenden Geometrie gefüllt. Dieser Collision-Radius berechnet sich aus dem umschließenden Radius der Geometrie mit der Formel $ceil(r_{geometry} * 2^{expTileScale})$.
Dieser Radius ist immer mindestens 1, was dazu führt das jede Geometrie immer mindestens auf 9 Tiles liegt. In den meisten Fällen liegt die Geometrie nicht wirklich auf allen diesen Tiles. Dies ist jedoch kein Problem da die endgültige Kollisionserkennung immer noch durch die genauen Formeln berechnet wird.
Es ist nur wichtig dass es keine Tiles gibt auf denen die Geometrie liegt die aber nicht diese enthalten.

Eine weitere Optimierung kann man beim Bewegen von Geometrien implementieren. Normalerweise werden, wenn eine Geometrie bewegt werden bei allen Tiles auf denen sie vorher gelegen ist die Einträge entfernt und bei allen neuen die Einträge hinzugefügt. Falls die Geometrie jedoch auf der gleichen \keyword{CollisionMapTile} bleibt muss die Map nicht aktualisiert werden. Deshalb wird in der Methode moveGeometry() zuerst überprüft ob eine Änderung Geschehen ist und nur dann die Map aktualisiert:

\doinline
\begin{lstlisting}[caption=Bewegen einer Geometrie in der CollisionMap, title=\hspace{0 pt}, language=java]
public boolean moveGeometry(float prevCenterX, float prevCenterY, CollisionGeometry geo) {
	if (getTileX(prevCenterX) == getTileX(geo.getCenterX()) && getTileY(prevCenterY) == getTileY(geo.getCenterY()))
		return true;
	
	boolean success = removeGeometry(geo, prevCenterX, prevCenterY);
	addGeometry(geo);
	
	return success;
}
\end{lstlisting}

Eine weitere Möglichkeit die Kollisionserkennung zu optimieren ist durch Einführung von Pseudo-Geometrien. Möchte eine Geometrie nur selbst mit anderen kollidieren aber nicht als Kollisionsobjekt dienen muss es sich nicht in die \keyword{CollisionMap} eintragen. Ein Beispiel hierfür wäre eine Kugel-Entity.
Diese besitzt eine \keyword{CollisionGeometry} um zu erkennen wann sie etwas getroffen hat. Jedoch gibt es normalerweise kein Fall in dem eine andere Entity wissen müsste ob die mit einer Kugel kollidiert.
Deshalb kann man einen Performancevorteil erlangen indem man die Kugel-Geometrie nicht in die \keyword{CollisionMap} einträgt und stattdessen selber verwaltet. Es gilt zu beachten dass man dies nicht mit zu vielen Entity-Typen machen sollten um nicht den Überblick zu verlieren wer mit wem kollidieren kann.
Außerdem muss die Kugel in jedem Schritt selbst ihre Kollisionen überprüfen, da es sonst keiner für sie tut.

\paragraph{Verwendung mit Entities}

In den meisten Fällen werden \keyword{CollisionGeometries} nicht alleinstehend benutzt sondern in Zusammenhang mit einer Entity. Aus diesem Grund sind die beiden Klassen auch eng miteinander verknüpft. So kann man einer Entity eine Liste an Geometrien hinzufügen, die diese Geometrie verwaltet. Wenn sich das Entity bewegt werden auch die Geometrien bewegt. Hierfür wird den Geometrien eine relative Position im Verhältnis zum Entity gegeben.
Außerdem wird jedes mal wenn die Entity sich  nach Kollisionen überpüft. Falls eine Kollision geschieht wird auf der bewegten Entity die Methode \ti{onActiveCollide()} aufgerufen und auf der anderen Entity \ti{onPassiveCollide()}. Diese beiden Methoden werden im Interface \keyword{CollisionListener} implementiert - welches die Klasse \keyword{Entity} standardmäßig hat. Außerdem wird wenn man eine Geometry zu einem Entity hinzufügt dieses automatisch in den \ti{listener}-Array der Geometrie aufgenommen. Dies ist der Array mit allen Klassen die benachrichtigt werden wenn eine Kollision stattfindet.

\paragraph{Analyse der Performance}

Um die Vorteile der einzelnen Optimierungen darzustellen, hier eine Tabelle mit Messwerten unter verschiedenen Bedingungen.

In jedem Test wurden eine gewisse Anzahl an Entities mit jeweils einer \keyword{CollisionGeometry} erstellt und gleichmäßig auf einer 128x128 Karte verteilt.
Jedes mal wird die Zeit gemessen die ein Update-Vorgang braucht in dem für jede Geometrie berechnet wird mit welchen anderen Geometrien sie kollidiert. Falls die Zeit so groß war das wir kein Ergebnis bekamen wurde \ti{NaN} eingetragen

\begin{itemize}
\item{\bf{Test 1}:} Rechteckige Hitboxen
\item{\bf{Test 2}:} Kreis Hitboxen (mit sqrt)
\item{\bf{Test 3}:} Kreis Hitboxen (ohne sqrt) 
\item{\bf{Test 4}:} Rechteckige Hitboxen (mit vorheriger Kreis Abschätzung)
\item{\bf{Test 5}:} Rechteckige Hitboxen in einer vollständigen CollisionMap 
\end{itemize}


\begin{tabular}{|r|r|r|r|r|r|}
\hline
Anzahl Geo's      & Test 1      & Test 2      & Test 3      & Test 4      & Test 5       \\ \hline\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
     128          &     1.03 ms &     0.95 ms &     0.76 ms &     0.66 ms &      0.28 ms \\ \hline
    1024          &    65.42 ms &    63.81 ms &    55.32 ms &    46.08 ms &      1.10 ms \\ \hline
   16384          & 22139.79 ms & 22199.35 ms & 18604.07 ms & 20451.18 ms &     58.59 ms \\ \hline
   65536          & \tcNaN      & \tcNaN      & \tcNaN      & \tcNaN      &    738.22 ms \\ \hline
  262144          & \tcNaN      & \tcNaN      & \tcNaN      & \tcNaN      &  11891.37 ms \\ \hline
16777216          & \tcNaN      & \tcNaN      & \tcNaN      & \tcNaN      & 219178.66 ms \\ \hline
\end{tabular}

\vspace*{1 cm}

Ein paar Dinge kann man direkt aus dieser Tabelle erkennen. Einerseits den offensichtlich extremen Vorteil der \keyword{CollisionMap} im Gegensatz zu allen anderen Ansätzen. Außerdem gibt es einen erkennbaren Performance Einbruch durch Verwendung von sqrt. Der Unterschied zwischen Kreis und Rechteck Kollision ist fast nicht da - dies ist in soweit erklärbar dass beides mathematisch einfach zu erkennen ist.

\quickfigure{Performance Graph der CollisionMap}{performance-collisionmap}{1.0}

\paragraph{Bewegung mit Kollisionen}

Kollisionserkennung ist nicht nur gut um zu erkennen wann zwei Entities kollidieren sondern auch um dies zu verhindern. Hat man beispielsweise eine vom Spieler gesteuerte Figur möchte man nicht dass diese stirbt wenn sie in einer Wand endet, sondern dass sie dies überhaupt nicht kann.
Dafür hat die Klasse \keyword{Entity} außer der setPosition() Methode auch noch die movePosition()-Methode. Diese bewegt das Entity entweder die komplette Strecke oder nur partiell falls zwischenzeitlich eine Kollision stattfindet.

Um dies zu zu schaffen bewegt man das Entity und all seine Geometrien zuerst die komplette Strecke. Dann sucht man die erste fremde Geometrie mit denen eine eigene Geometrie kollidiert. Für diese Geometrie berechnet man dann die Entfernung die man rückwärts gehen muss dass sich die beiden Geometrien nicht mehr überschneiden. Dies wiederholt man solange bis es für keine eigene Geometrie mehr eine Überschneidung gibt. Jedoch führt man dies nicht für die ganze Bewegung aus sondern einmal für die Bewegung in X-Richtng und dann noch einmal in Y-Richtung. X und Y Bewegung sind somit unabhängig und es ist möglich beispielsweise an einer Wand "entlang zu gleiten" indem die X-Bewegung verhindert wird aber die Y-Bewegung immer noch ausgeführt.

Mathematisch interessant ist hierbei die Algorithmen um den minimalen Abstand zu berechnen. Wir brauchen eine Methode die zwei Geometrien, positioniert durch ihren Mittelpunkt, bekommt und uns den minimalen Abstand in X oder Y Richtung sagt bei denen dies sich gerade nicht schneiden. Dies führt zu acht unterschiedlichen Methoden: Der Kreis-Kreis, Kreis-Rechteck, Rechteck-Kreis und Rechteck-Rechteck Abstand jeweils in X und Y Richtung.

Der Kreis-Kreis Abstand lässt sich einfach durch diese Formel berechnen:

$$d_x = \sqrt{(r_1 + r_2)^2 - (y_2 - y_1)} * signum(x_2 - x_1)$$:

\quickfigure{Berechnung des minimalen X-Abstands zweier Kreise}{x-touch-dist_1}{0.6}

Der Kreis-Rechteck Abstand muss wieder zwei Fälle abdecken. Wenn der Kreis neben dem Rechteck ist, ist dies die Formel:

$$d_x = (r_1 + \frac{width_2}{2}) * signum(x_2 - x_1)$$. 

Befindet sich der Kreis über oder unter dem Rechteck ist die Formel die gleiche wie bei dem Kreis-Kreis Abstand:

$$d_x = \sqrt{(r_1)^2 - (y_{2bl} - y_1)} * signum(x_2 - x_1)$$

\quickfigure{Berechnung des minimalen X-Abstands eines Kreises und eines Rechtecks}{x-touch-dist_2}{0.6}

Der Rechteck-Kreis Fall ist der selbe wie Kreis-Rechteck nur mit getauschten Vorzeichen. Und beim Rechteck-Rechteck Fall bestimmt man den Abstand mit:

$$d_x = \frac{width_1 + width_2}{2}$$

\quickfigure{Berechnung des minimalen X-Abstands zweier Rechtecke}{x-touch-dist_3}{0.6}

Nun gibt es in der Klasse \keyword{CollisionListener} auch noch Events für solche verhinderten Kollisionen. Kollidiert eine Geometrie in ihrer eigenen Bewegung wird die Methode \ti{onActiveMovementCollide()} bei dem bewegten Entity aufgerufen und bei dem anderen \ti{onPassiveMovementCollide}.

Ein Problem können hier Entities mit mehreren \keyword{CollisonGeometries} sein. Hierbei muss drauf geachtet werden, dass alle Geometrien in der Kollison beachtet werden und jeweils der größte "Rücksetz-Wert" benutzt wird.

Ein weiteres Problem sind entstehende Rundungsfehler bei Verwendung von FloatingPoint Zahlen. Führt man den Algorithmus exakt so wie oben beschrieben aus kann es vorkommen dass sich die beiden Geometrien auch nach dem Rücksetzen immer noch schneiden. Der einzige Weg um dieses Problem herum ist es einen delta Wert in der Berechnung des minimalen Abstands einzuführen. Damit wird nicht mehr der minimale Abstand zurückgeliefert sonder der minimale Abstand plus einen delta Wert. Somit können sich Entities nicht mehr "wirklich" berühren sondern nur noch bis maximal delta Einheiten nähern.

Ein letztes Problem ist das sogenannte Discrete-Time-Issue \cite[S 503]{DGIJ}. Falls die Updaterate niedrig genug ist kann es vorkommen, dass ein Objeckt links neben einem anderen ist und sich dann schnell genug nach rechts bewegt um im nächsten Schritt rechts neben dem Objekt zu sein. Obwohl sich das Entity nun direkt durch ein anderes bewegt hat wurde an keiner Stelle eine Kollision bemerkt. Zwar gibt es mathematische Ansätze dieses Problem zu lösen, diese gehen jedoch auf Kosten der Performance. Einfacher ist es eine konstante Update-Rate aufrecht zu erhalten und keine extrem dünne Entities zu verwenden, wo Kollisionen wichtig sind.

\quickfigure{Discrete-Time-Issue: Ein Objekt "phased" durch ein anderes}{discrete-time-issue_phasing}{1.0}

\paragraph{Kollisionen mit der Karte}

\paragraph{Limitierte Kollisionen}