Zwar commiten wir unser Code mit git in unsere Repository, jedoch nicht alle Dateien. Es gibt eine Reihe an Dateien, die nur tempor√§r sind und beispielsweise bei jedem Kompiliervorgang neu erzeugt werden. Es w√§re sinnlos, solche Dateien in die Versionskontrolle aufzunehmen, vor allem da sie sich immer √§ndern w√ºrden und so die History mit unn√∂tigen Daten belasten w√ºrden. Es gibt jedoch auch Dateien, die zwar wichtig sind, trotzdem aber nicht in die Versionskontrolle geh√∂ren. Dies sind einerseits Konfigurationsdateien mit lokalen Pfaden, die ung√ºltig auf anderen System w√§ren, IDE spezifische Dateien die unn√ºtz f√ºr Nutzer anderer IDE's w√§ren oder externe Libraries, die oftmals zu gro√ü sind, um sie alle in die Repository zu commiten.

Trotzdem sind Libraries und IDE-Dateien wichtig und eine dritte Person, die das Projekt zum ersten mal √∂ffnet, sollte diese Dateien nicht erst selbst erstellen beziehungsweise manuell herunterladen m√ºssen.

Um diese Probleme k√ºmmert sich nun ein weiteres Tool namens gradle \footnote{\url{http://www.gradle.org/}}. Gradle ist ein Build-Managment-Automatisierung-Tool. Dies bedeutet, dass wir in unser Git-Repository nur noch die gradle Konfigurationsdateien commiten und diese dann jeweils auf den Entwicklerrechnern ausf√ºhren. Diese l√∂st dann die Projektabh√§ngigkeiten auf, l√§dt fehlende Libraries automatisch nach und erstellt au√üerdem Dateien, wie die IDE-Projektdateien, automatisch.

\paragraph{Dependency Management}

In gradle kann man angeben von welchen Bibliotheken oder Projekten ein Programm abh√§ngig ist. Diese Bibliotheken k√∂nnen dann wiederum von anderen Bibliotheken abh√§ngig sein und so bildet sich ein Abh√§ngigkeitsbaum, ausgehend vom Anfangsprojekt.
Gradle l√§dt dann diese Bibliotheken, falls sie noch nicht auf dem Rechner vorhanden sind. Dies hat auch den Vorteil, falls eine Bibliothek √∂fters im Abh√§ngigkeitsbaum auftaucht, sie trotzdem nur einmal geladen werden muss.\cite[S. 55]{BATWG}

Gradle unterst√ºtzt viele verschiedene Repositories, in welcher nach fehlenden Bibliotheken gesucht werden kann. Standardm√§√üig wird jedoch die \ti{Maven Central Repository} \footnote{\url{http://search.maven.org/}} benutzt.
In dieser Repository sind sehr viele der frei verf√ºgbaren java Libraries in vielen Versionen enthalten und k√∂nnen zum Beispiel einfach √ºber gradle geladen werden.

\paragraph{Konfiguration}

Die Konfiguration geschieht √ºber \keyword{build.gradle} Dateien, welche in der Sprache \keyword{Groovy} geschrieben sind.\cite{GRADLE}[S. 73]
absGDX ist ein Multiprojekt. Dies bedeutet, dass es  aus mehreren Gradle Projekten besteht mit jeweils eigenen Konfigurationen, die voneinander abh√§ngen. \cite[S. 79ff]{BATWG}

In der folgenden Grafik kann man unseren Abh√§ngigkeitsbaum sehen. Die orange markierten Felder sind unsere Projekte, die weiﬂ markierten Felder stellen die externe Abh√§ngigkeiten dar.

\quickfigure{Gradle Dependency Graph absGDX}{dependency-graph-gradle.png}{1.0}

Das Projekt \keyword{absGDX-framework} ist hierbei das eigentliche Framework, das wir entwickeln. \keyword{asGDX-test} ist das Testprojekt. Es enth√§lt alle Unit-tests f√ºr das Framework.
\keyword{absGDX-core} und die beiden Plattformprojekte \keyword{desktop} und \keyword{android} sind zum Testen und Debuggen. Wird das Framework sp√§ter f√ºr ein Projekt benutzt, kommt in diese Projekte der eigentliche Code und \keyword{absGDX-framework} wird als Dependency eingebunden. W√§hrend wir jedoch das Framework noch entwickeln, sind diese Projekte notwendig, damit wir es auch ausprobieren k√∂nnen.

Da wir alle an dem Projekt mit der Eclipse IDE entwickeln, haben wir ein paar extra Eclipse Einstellungen in die build.gradle Dateien ausgelagert:

\doinline
\begin{lstlisting}[caption=Eclipse Optionen in gradle setzen, title=\hspace{0 pt}, language=groovy]
eclipse.jdt.file.withProperties { props ->
    props.setProperty('org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body', '0')
    props.setProperty('org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve', '1')
    props.setProperty('org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line', 'true')
    props.setProperty('org.eclipse.jdt.core.formatter.tabulation.char', 'tab')
    props.setProperty('org.eclipse.jdt.core.formatter.tabulation.size', '4')
    props.setProperty('org.eclipse.jdt.core.formatter.use_on_off_tags', 'false')
    props.setProperty('org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations', 'false')
    props.setProperty('org.eclipse.jdt.core.formatter.wrap_before_binary_operator', 'true')
    props.setProperty('org.eclipse.jdt.core.formatter.wrap_before_or_operator_multicatch', 'true')
    props.setProperty('org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested', 'true')
    // ...
}
\end{lstlisting}

Dies ist ein gutes Beispiel wie m√§chtig die Groovy Konfigurationsdateien sind, wir f√ºgen in die generierten Eclipse property files hier noch unsere eigenen Felder ein.
In diesem Beispiel setzen wir die Einstellungen f√ºr projektspezifische Formatierungen, damit der automatische Quellcodeformattierer bei allen, die das Projekt in Eclipse laden gleich funktioniert.

\paragraph{Verwendung in unserem Projekt}

Um Problemen mit verschiedenen Versionen von gradle entgegen zu wirken, ist in unserer git Repository nicht nur die build.gradle Dateien vorhanden, sondern auch der \ti{gradle Wrapper}. Dies ist eine vollst√§ndige, unabh√§ngige Version von gradle, die man anstatt der lokal installierten verwenden soll. Damit ist garantiert, dass jeder die gleiche Version von gradle verwendet.

Ausgef√ºhrt wird sie dann √ºber die Kommandozeile mit Befehlen wie

\begin{lstlisting}[caption=Gradle in der Kommandozeile, title=\hspace{0 pt}, style=cmd]
> gradlew cleanEclipse eclipse afterclipseImport
\end{lstlisting}

Dieses Beispiel f√ºhrt zuerst den Task \ti{cleanEclispe} aus, um alle Dateien, die mit der Eclipse IDE zusammenh√§ngen zu l√∂schen. Dann werden sie mit \ti{eclipse} neu aus den gradle Einstellungen erzeugt. Zuletzt werden mit \ti{afterEclipseImport} einige √Ñnderungen vorgenommen. Der letzte Task ist von LibGDX vorgegeben, damit das Android Projekt richtig konfiguriert ist.
